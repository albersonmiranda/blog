---
title: 'Python from R I: package importing'
author: Alberson Miranda
date: '2021-06-02'
slug: [package-importing]
categories:
  - languages
tags:
  - Python
  - R
series: Python from R
description: Comparing package importing in R and Python.
featured: yes
draft: false
featureImage: img/r-python.jpg
thumbnail: images/python.jpg
shareImage: images/python.jpg
codeMaxLines: 10
codeLineNumbers: yes
figurePositionShow: yes
bibliography: [bib.bib] 
link-citations: true
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>Python from R is a collaborative initiative to write a book to help experienced R users learn Python. In the words of my boi <a href="https://twitter.com/BenjaminWolfe">Benjamin Wolfe</a> in the Python from R Slack channel:</p>
<blockquote>
<ul>
<li>We‚Äôre a group of people who either learned Python from R, are R users currently learning Python, or have yet to learn Python, but are comfortable with R.</li>
<li>What we hope to do is write some collaborative resources for others like ourselves to find their way more easily.</li>
<li>We will work in the open, for anyone ‚Äúout there‚Äù to find and benefit from (and collaborate on!) along the way.</li>
<li>In the end, we envision this looking like a book ‚Äî whether that means a literal, physical, published print book, or an online one.</li>
</ul>
</blockquote>
<div id="motivation" class="section level1">
<h1>MOTIVATION</h1>
<p>When I was writing my concept map for the book (we‚Äôll write about it eventually), it crossed my mind an analogy about learning a foreign language: <em>it‚Äôs impossible to learn a new language by translating word by word</em>. It‚Äôs not only a matter of vocabulary. I mean, each language has it‚Äôs own grammar, phrasal verbs, diction, expressions, pace etc. That kind of issue also appears when learning a new <em>programming language</em> and I think importing packages is a good, yet very simple, example of that.</p>
</div>
<div id="calling-a-function-from-a-package" class="section level1">
<h1>CALLING A FUNCTION FROM A PACKAGE</h1>
<div id="r-experience" class="section level2">
<h2>R EXPERIENCE</h2>
<p>In R, every package installed in the library trees are listed whenever a terminal is open. Those listed packages are available for users at all times and can be called explicitly. For example:</p>
<div id="case-1-explicit-call" class="section level3">
<h3>CASE 1: EXPLICIT CALL</h3>
{{% highlight "r" %}}

# search for machine learning measures that contais "AUC" in the {mlr3} package
mlr3::mlr_measures$keys("auc")

{{% /highlight %}}
<pre><code>## [1] &quot;classif.auc&quot;   &quot;classif.prauc&quot;</code></pre>
<p>But that way of calling functions usually take place only if that particular package won‚Äôt be required very often. Otherwise, it‚Äôs cultural for R users to load and attach the entire package‚Äôs namespace to the search path<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> with a <code>library()</code> call.</p>
</div>
<div id="case-2-attaching" class="section level3">
<h3>CASE 2: ATTACHING</h3>
{{% highlight "r" %}}

# tired: explicitly calling from {ggplot2}
p1 = mtcars |>
ggplot2::ggplot(ggplot2::aes(x = hp, y = mpg, color = factor(cyl))) +
  ggplot2::geom_point() +
  ggplot2::labs(color = "cyl")

{{% /highlight %}}
{{% highlight "r" %}}

# wired: attaching {ggplot2} namespace
library(ggplot2)

p2 = mtcars |>
ggplot(aes(x = hp, y = mpg, color = factor(cyl))) +
  geom_point() +
  labs(color = "cyl")

{{% /highlight %}}
{{% highlight "r" %}}

# are they equivalent?
all.equal(p1,p2)

{{% /highlight %}}
<pre><code>## [1] TRUE</code></pre>
<p>The problem appears when there are namespace conflicts. Say we attach {plotly} for interactive graphs. Usually, users just don‚Äôt care for startup warnings üò® and that may eventually lead them to inconsistent results or tricky errors.</p>
{{% highlight "r" %}}

# attaching plotly
library(plotly)

# plotly plot
p3 = ggplotly(p2)

{{% /highlight %}}
<pre><code>## 
## Attaching package: &#39;plotly&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:ggplot2&#39;:
## 
##     last_plot</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     filter</code></pre>
<pre><code>## The following object is masked from &#39;package:graphics&#39;:
## 
##     layout</code></pre>
<p>That can be avoided by attaching only the specific functions you‚Äôre actually gonna use:</p>
</div>
<div id="case-3-attaching-specific-functions" class="section level3">
<h3>CASE 3: ATTACHING SPECIFIC FUNCTIONS</h3>
{{% highlight "r" %}}

# detaching plotly
detach("package:plotly")

# attaching only ggplotly():
library(plotly, include.only = "ggplotly")

{{% /highlight %}}
<p>And no conflict warning will be triggered. Unfortunately, you won‚Äôt be hearing much of <code>include.only</code> argument from R community ü§∑‚Äç‚ôÇ. On the contrary, meta packages such as {tidyverse}, which will load and attach A LOT of stuff into the namespace ‚Äî often unnecessary for what you‚Äôre about to do ‚Äî, is quite common among casual users/analysis.</p>
</div>
</div>
<div id="python-experience" class="section level2">
<h2>PYTHON EXPERIENCE</h2>
<p>All of the 3 cases stated before are possible in Python, but the community behaves in a very different manner. Specially regarding to the awareness of what is loaded into the namespace ‚Äî or symbol table, as it is called in Python.</p>
<p>Firstly, installed packages aren‚Äôt immediately available. So if I try, for example, listing {pandas} functions/methods/attributes it‚Äôll result in an error:</p>
{{% highlight "python" %}}

# inspecting {pandas}
dir(pandas)

{{% /highlight %}}
<pre><code>## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;pandas&#39; is not defined
## 
## Detailed traceback:
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<p>One can check the symbol table with the following statement.</p>
{{% highlight "python" %}}

# what is attached into the symbol table?
print(*globals(), sep = "\n")

{{% /highlight %}}
<pre><code>## __name__
## __doc__
## __package__
## __loader__
## __spec__
## __annotations__
## __builtins__
## sys
## os
## r</code></pre>
<p>Depending on what system/tools you‚Äôre using, Python interpreter will load a few modules or not. If you start a REPL ‚Äî a Python interactive terminal ‚Äî, no modules will be leaded. If you start a Jupyter notebook, a few modules necessary for it to run will be loaded. In this case, since I‚Äôm running Python from R via {reticulate}, some modules have been loaded:</p>
<ul>
<li><code>sys</code>: for accesses to some variables and functions used by the interpreter</li>
<li><code>os</code>: for OS routines for NT or Posix</li>
</ul>
<p>So if I want to work with {pandas}, I need to attach it to the symbol table with an equivalent to R‚Äôs <code>library()</code>. And just like it‚Äôs cousin function, Python‚Äôs <code>import</code> also comes in different flavours.</p>
<p>Firstly, <code>import pandas</code> will make the package available for explicit calls.</p>
{{% highlight "python" %}}

# import pandas
import pandas

# what is attached into the symbol table?
print(*globals(), sep = "\n")

{{% /highlight %}}
<pre><code>## __name__
## __doc__
## __package__
## __loader__
## __spec__
## __annotations__
## __builtins__
## sys
## os
## r
## pandas</code></pre>
<p>Note that only {pandas} is attached to the symbol table, not it‚Äôs functions/methods/attributes. So that statement it‚Äôs not an equivalent to <code>library()</code>. For us to create a simple dataframe with {pandas}:</p>
<div id="case1py" class="section level3">
<h3>CASE 1: EXPLICIT CALL</h3>
{{% highlight "python" %}}

# this won't work because DataFrame isn't in symbol table
DataFrame(
  {
    "capital": ["Vitoria", "S√£o Paulo", "Rio de Janeiro"],
    "state": ["Esp√≠rito Santo", "S√£o Paulo", "Rio de Janeiro"]
  }
)

# this will
pandas.DataFrame(
  {
    "capital": ["Vitoria", "S√£o Paulo", "Rio de Janeiro"],
    "state": ["Esp√≠rito Santo", "S√£o Paulo", "Rio de Janeiro"]
  }
)

{{% /highlight %}}
<pre><code>## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;DataFrame&#39; is not defined
## 
## Detailed traceback:
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<pre><code>##           capital           state
## 0         Vitoria  Esp√≠rito Santo
## 1       S√£o Paulo       S√£o Paulo
## 2  Rio de Janeiro  Rio de Janeiro</code></pre>
<p>If we were to replicate <code>library()</code> behavior (i.e.¬†load and attach the entire {pandas} functions/methods/attributes into the symbol table), then:</p>
</div>
<div id="case2py" class="section level3">
<h3>CASE 2: ATTACHING</h3>
{{% highlight "python" %}}

# importing entire {pandas} into symbol table
from pandas import *

# the updated symbol table
print(*globals(), sep = "
")

# and now this works
DataFrame(
  {
    "capital": ["Vitoria", "S√£o Paulo", "Rio de Janeiro"],
    "state": ["Esp√≠rito Santo", "S√£o Paulo", "Rio de Janeiro"]
  }
)

{{% /highlight %}}
<pre><code>## __name__
## __doc__
## __package__
## __loader__
## __spec__
## __annotations__
## __builtins__
## sys
## os
## r
## pandas
## compat
## get_option
## set_option
## reset_option
## describe_option
## option_context
## options
## core
## errors
## util
## io
## tseries
## arrays
## plotting
## Int8Dtype
## Int16Dtype
## Int32Dtype
## Int64Dtype
## UInt8Dtype
## UInt16Dtype
## UInt32Dtype
## UInt64Dtype
## CategoricalDtype
## PeriodDtype
## IntervalDtype
## DatetimeTZDtype
## StringDtype
## BooleanDtype
## NA
## isna
## isnull
## notna
## notnull
## Index
## CategoricalIndex
## Int64Index
## UInt64Index
## RangeIndex
## Float64Index
## MultiIndex
## IntervalIndex
## TimedeltaIndex
## DatetimeIndex
## PeriodIndex
## IndexSlice
## NaT
## Period
## period_range
## Timedelta
## timedelta_range
## Timestamp
## date_range
## bdate_range
## Interval
## interval_range
## DateOffset
## to_numeric
## to_datetime
## to_timedelta
## Grouper
## factorize
## unique
## value_counts
## NamedAgg
## array
## Categorical
## set_eng_float_format
## Series
## DataFrame
## SparseDtype
## infer_freq
## offsets
## eval
## concat
## lreshape
## melt
## wide_to_long
## merge
## merge_asof
## merge_ordered
## crosstab
## pivot
## pivot_table
## get_dummies
## cut
## qcut
## api
## show_versions
## ExcelFile
## ExcelWriter
## read_excel
## read_csv
## read_fwf
## read_table
## read_pickle
## to_pickle
## HDFStore
## read_hdf
## read_sql
## read_sql_query
## read_sql_table
## read_clipboard
## read_parquet
## read_orc
## read_feather
## read_gbq
## read_html
## read_json
## read_stata
## read_sas
## read_spss
## json_normalize
## test
## testing</code></pre>
<pre><code>##           capital           state
## 0         Vitoria  Esp√≠rito Santo
## 1       S√£o Paulo       S√£o Paulo
## 2  Rio de Janeiro  Rio de Janeiro</code></pre>
<p>But you won‚Äôt see any experienced Python user doing that kind of thing because they‚Äôre worried about loading that amount of names into the symbol table and the possible conflicts it may cause. An acceptable approach would be attaching only a few frequent names as in:</p>
</div>
<div id="case3py" class="section level3">
<h3>CASE 3: ATTACHING SPECIFIC FUNCTIONS</h3>
{{% highlight "python" %}}

# detaching {pandas}
for name in vars(pandas):
    if not name.startswith("_"):
        del globals()[name]

# attaching only DataFrame()
from pandas import DataFrame

# the updated symbol table
print(*globals(), sep = "
")

{{% /highlight %}}
<pre><code>## __name__
## __doc__
## __package__
## __loader__
## __spec__
## __annotations__
## __builtins__
## sys
## os
## r
## name
## DataFrame</code></pre>
<p>According to The Hitchhiker‚Äôs Guide to Python <span class="citation">(<a href="#ref-pythonguide" role="doc-biblioref">Kenneth Reitz and Tanya Schlusser 2016</a>)</span>, case 3 is the worst possible scenario and it‚Äôs generally considered bad practice since it ‚Äúmakes code harder to read and makes dependencies less compartmentalized.‚Äù <a href="#case2py">Case 2</a>, in the other hand, would be a better option because it pinpoints specific names, while <a href="#case1py">case 1</a> would be the best practice, for ‚ÄúBeing able to tell immediately where a class or function comes from greatly improves code readability and understandability in all but the simplest single file projects.‚Äù</p>
</div>
</div>
</div>
<div id="tldr" class="section level1">
<h1>TL;DR</h1>
<p>When learning a new programming language, simply finding equivalent code for the practices you already have may be misleading. Here we‚Äôre able to see that an equivalent of R‚Äôs <code>library()</code> call is actually considered a bad practice in Python and if you do that in a job interview, you should not expect they call you back üòÇ</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>REFERENCES</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-pythonguide" class="csl-entry">
Kenneth Reitz and Tanya Schlusser. 2016. <em>The Hitchhiker‚Äôs Guide to Python!</em> O‚ÄôReilly Media. <a href="https://docs.python-guide.org/">https://docs.python-guide.org/</a>.
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>An ordered list where R will look for a function. Can be accessed with <code>search()</code>.<a href="#fnref1" class="footnote-back">‚Ü©Ô∏é</a></p></li>
</ol>
</div>
